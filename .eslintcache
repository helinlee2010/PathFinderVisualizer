[{"/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/index.js":"1","/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/App.js":"2","/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/components/PathFind.js":"3","/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/components/Node.js":"4","/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/algorithms/astar.js":"5"},{"size":220,"mtime":1607073037683,"results":"6","hashOfConfig":"7"},{"size":179,"mtime":1607073311127,"results":"8","hashOfConfig":"7"},{"size":5081,"mtime":1607234549820,"results":"9","hashOfConfig":"7"},{"size":361,"mtime":1607223727373,"results":"10","hashOfConfig":"7"},{"size":2466,"mtime":1607233347301,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"8j6g5r",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/index.js",[],["24","25"],"/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/App.js",[],"/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/components/PathFind.js",["26"],"import React, { useState, useEffect } from 'react';\nimport './PathFind.css';\nimport Node from './Node';\nimport Astar from '../algorithms/astar';\n\nconst rows = 10;\nconst cols = 20;\n\nconst NODE_BEGIN_ROW = 0;\nconst NODE_BEGIN_COL = 0;\nconst NODE_END_ROW = rows-1;\nconst NODE_END_COL = cols-1;\n\nconst PathFind = () =>{ \n    const [Grid, setGrid] = useState([]);\n    const [Path, setPath] = useState([]);\n    const [visited, setVisited] = useState([]);\n    // const [reset, setReset] = useState(false);    \n    useEffect(()=>{\n        initGrid();\n    },[]);\n\n    const initGrid = () =>{\n        // Generate 2D array grid\n        let grid = new Array(rows);\n        for(let i=0; i<rows; i++){\n            grid[i] = new Array(cols);\n        }\n        // Populate the grid with Spot\n        for(let i=0; i<rows; i++){\n            for(let j=0; j<cols; j++){\n                grid[i][j] = new Spot(i,j);\n            }\n        }\n        gridWithNeighbors(grid);\n        // Hook this grid to state\n        setGrid(grid);\n\n        const startNode = grid[NODE_BEGIN_ROW][NODE_BEGIN_COL];\n        const endNode = grid[NODE_END_ROW][NODE_END_COL];\n        startNode.isWall = false;\n        endNode.isWall = false;\n        let algoResult = Astar(startNode, endNode);\n        setPath(algoResult.path);\n        setVisited(algoResult.visited);\n    }\n\n    // Spot constructor\n    function Spot(i, j){\n        this.x = i; //rowIdx\n        this.y = j; //colIdx\n        this.isWall = false;\n        // Randomly define walls with 15% probability\n        if(Math.random()<=0.15){\n            this.isWall = true;\n        }\n        this.prev = undefined;\n        this.neighbors = [];\n        this.addNeighbors = (grid) => {\n            const x = this.x;\n            const y = this.y;\n            if(y>0) this.neighbors.push(grid[x][y-1]);\n            if(y<cols-1) this.neighbors.push(grid[x][y+1]);\n            if(x>0) this.neighbors.push(grid[x-1][y]);\n            if(x<rows-1) this.neighbors.push(grid[x+1][y]);\n        }    \n        // Evalaute if this spot is start or end\n        this.isStart = (this.x === NODE_BEGIN_ROW && this.y === NODE_BEGIN_COL);\n        this.isEnd = (this.x === NODE_END_ROW && this.y === NODE_END_COL);\n        this.g = 0;\n        this.f = 0;\n        this.h = 0;\n    }\n\n    // AddNeighbors for each cell in the grid\n    const gridWithNeighbors = (grid) =>{\n        for(let i=0; i<rows; i++){\n            for(let j=0; j<cols; j++){\n                grid[i][j].addNeighbors(grid);\n            }\n        }\n    }\n\n    // JSX chunk: populate the grid with Node component\n    const gridWithNode = (\n        <div>\n            {\n            Grid.map( (row, rowIdx) => {\n                return(\n                    <div key={rowIdx} className='row-wrapper'>\n                        {row.map((cell, colIdx)=>{\n                            const { isStart, isEnd, isWall } = cell;\n                            return <Node \n                                    key={colIdx} \n                                    isStart={isStart} \n                                    isEnd={isEnd}\n                                    isWall={isWall}\n                                    row={rowIdx}\n                                    col={colIdx}\n                                />\n                        })}\n                    </div>\n                )\n            })}\n        </div>\n    );\n\n    const visualizeFinalPath = (nodesInPath) =>{\n        for(let i=0; i< nodesInPath.length; i++){\n            const node = nodesInPath[i];\n            if(!node.isStart && !node.isEnd){\n                const nodeElm = document.getElementById(`node-${node.x}-${node.y}`);\n                nodeElm.classList.add(\"shortest-path\");\n            }   \n        }\n    }\n    const visualize = ()=>{\n        console.log(\"Visualizing\");\n        for(let i=0; i<=visited.length; i++){\n            // If reaching the last one in visited records\n            if(i === visited.length){\n                setTimeout(()=>visualizeFinalPath(Path), 10*i+100);\n            }else{ // visualize the footprint\n                setTimeout( ()=>{\n                    const node = visited[i];\n                    if(!node.isStart && !node.isEnd){\n                        const nodeElm = document.getElementById(`node-${node.x}-${node.y}`);\n                        nodeElm.classList.add(\"visited\");\n                    }\n                }, 10*i);     \n            }\n        }\n    }\n    // const cleanUp = ()=>{ //??Figure out how to\n    //     setReset(true);\n    //     setGrid([]);\n    //     setPath([]);\n    //     setVisited([]);\n    //     initGrid();\n    //     setReset(false);\n    // }\n\n    const reloadPage = () =>{\n        window.location.reload();\n    }\n\n    return(\n        <div className='big-container'>\n            <h1 style={{color:'thistle'}}>Path Finder with A*</h1>\n            <div className=\"button-wrapper\">\n                <button onClick={visualize}>Visualize</button>\n                <button onClick={reloadPage}>Reset</button>\n            </div> \n            {gridWithNode}\n        </div>\n    ); \n}\n\nexport default PathFind;","/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/components/Node.js",[],"/Users/helinli/Desktop/Web_Development/path_finding_visualizer/src/algorithms/astar.js",[],{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","severity":1,"message":"32","line":21,"column":7,"nodeType":"33","endLine":21,"endColumn":9,"suggestions":"34"},"no-native-reassign",["35"],"no-negated-in-lhs",["36"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'initGrid'. Either include it or remove the dependency array.","ArrayExpression",["37"],"no-global-assign","no-unsafe-negation",{"desc":"38","fix":"39"},"Update the dependencies array to be: [initGrid]",{"range":"40","text":"41"},[549,551],"[initGrid]"]