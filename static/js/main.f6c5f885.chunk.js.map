{"version":3,"sources":["components/Node.js","algorithms/astar.js","components/PathFind.js","App.js","index.js"],"names":["Node","isStart","isEnd","isWall","row","col","additionalClass","className","id","heuristic","pCell","qCell","Math","abs","x","y","Astar","startNode","endNode","openSet","closeSet","path","visited","push","winnerIdx","i","length","f","curr","neighbors","console","log","temp","prev","filter","item","currNeighbor","tempG","g","newPath","includes","h","error","rows","PathFind","useState","Grid","setGrid","Path","setPath","setVisited","useEffect","initGrid","grid","Array","j","Spot","gridWithNeighbors","cols","algoResult","this","random","undefined","addNeighbors","gridWithNode","map","rowIdx","cell","colIdx","style","color","onClick","setTimeout","nodesInPath","node","document","getElementById","classList","add","visualizeFinalPath","window","location","reload","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.f6c5f885.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nconst Node = ({isStart, isEnd, isWall, row, col})=>{\n    const additionalClass = isStart? \"start-node\" : isWall? \"wall-node\": (isEnd? \"end-node\" : \"\");\n    return(\n        <div \n            className={`node ${additionalClass}`} \n            id={`node-${row}-${col}`}>\n        </div>\n    );\n}\nexport default Node;","function Astar(startNode, endNode){\n    let openSet=[]; //to be evaulated\n    let closeSet=[]; // store nodes that have been evaluated\n    let path=[]; // store nodes in the optimal path\n    let visited = [];\n    \n    openSet.push(startNode);\n    let winnerIdx = 0;\n    while(openSet.length>0){\n        for(let i=0; i<openSet.length; i++){\n            if(openSet[i].f<openSet[winnerIdx].f){\n                // Update the new winner index (that has the shortestPath)\n                winnerIdx=i; \n            }\n        }\n        let curr = openSet[winnerIdx];\n        let neighbors = curr.neighbors; // array\n        visited.push(curr);\n\n        if(curr === endNode){\n            console.log(\"Path found by algorithm.\");\n            let temp = curr;\n            path.push(temp);\n            while(temp.prev){\n                path.push(temp.prev);\n                temp = temp.prev;\n            }\n            return {path, visited};\n        }\n        // Remove curr from openSet\n        openSet = openSet.filter( item => item!== curr);\n        // Add curr to closeSet\n        closeSet.push(curr);\n        \n        // Process all the curr's neighbors\n        for(let i=0; i<neighbors.length; i++){\n            let currNeighbor = neighbors[i];\n            let tempG = curr.g + 1;   //** \n            let newPath = false; \n\n            if(!closeSet.includes(currNeighbor) && !currNeighbor.isWall){\n                if(openSet.includes(currNeighbor)){\n                    // Update the g with the smaller one\n                    if(tempG < currNeighbor.g){\n                        currNeighbor.g = tempG;\n                        newPath = true;\n                    }\n                }else{ // openSet doesn't have this neighbot\n                    currNeighbor.g = tempG;\n                    newPath = true;\n                    openSet.push(currNeighbor);\n                }\n                if(newPath){\n                    // Calculate the heuristic, update the h & f value\n                    currNeighbor.h = heuristic(currNeighbor, endNode);\n                    currNeighbor.f = currNeighbor.g + currNeighbor.h;\n                    currNeighbor.prev = curr; \n                }\n            } //won't do anything if curr neighbor is in closeSet   \n        }\n    }\n    return {path, visited, error:\"No path found\"};\n}\n\nfunction heuristic(pCell, qCell){\n    const distance = Math.abs(pCell.x-qCell.x) + Math.abs(pCell.y-qCell.y);\n    return distance;\n}\n\nexport default Astar;","import React, { useState, useEffect } from 'react';\nimport './PathFind.css';\nimport Node from './Node';\nimport Astar from '../algorithms/astar';\n\nconst rows = 10;\nconst cols = 20;\n\nconst NODE_BEGIN_ROW = 0;\nconst NODE_BEGIN_COL = 0;\nconst NODE_END_ROW = rows-1;\nconst NODE_END_COL = cols-1;\n\nconst PathFind = () =>{ \n    const [Grid, setGrid] = useState([]);\n    const [Path, setPath] = useState([]);\n    const [visited, setVisited] = useState([]);\n    // const [reset, setReset] = useState(false);    \n    useEffect(()=>{\n        initGrid();\n    },[]);\n\n    const initGrid = () =>{\n        // Generate 2D array grid\n        let grid = new Array(rows);\n        for(let i=0; i<rows; i++){\n            grid[i] = new Array(cols);\n        }\n        // Populate the grid with Spot\n        for(let i=0; i<rows; i++){\n            for(let j=0; j<cols; j++){\n                grid[i][j] = new Spot(i,j);\n            }\n        }\n        gridWithNeighbors(grid);\n        // Hook this grid to state\n        setGrid(grid);\n\n        const startNode = grid[NODE_BEGIN_ROW][NODE_BEGIN_COL];\n        const endNode = grid[NODE_END_ROW][NODE_END_COL];\n        startNode.isWall = false;\n        endNode.isWall = false;\n        let algoResult = Astar(startNode, endNode);\n        setPath(algoResult.path);\n        setVisited(algoResult.visited);\n    }\n\n    // Spot constructor\n    function Spot(i, j){\n        this.x = i; //rowIdx\n        this.y = j; //colIdx\n        this.isWall = false;\n        // Randomly define walls with 15% probability\n        if(Math.random()<=0.15){\n            this.isWall = true;\n        }\n        this.prev = undefined;\n        this.neighbors = [];\n        this.addNeighbors = (grid) => {\n            const x = this.x;\n            const y = this.y;\n            if(y>0) this.neighbors.push(grid[x][y-1]);\n            if(y<cols-1) this.neighbors.push(grid[x][y+1]);\n            if(x>0) this.neighbors.push(grid[x-1][y]);\n            if(x<rows-1) this.neighbors.push(grid[x+1][y]);\n        }    \n        // Evalaute if this spot is start or end\n        this.isStart = (this.x === NODE_BEGIN_ROW && this.y === NODE_BEGIN_COL);\n        this.isEnd = (this.x === NODE_END_ROW && this.y === NODE_END_COL);\n        this.g = 0;\n        this.f = 0;\n        this.h = 0;\n    }\n\n    // AddNeighbors for each cell in the grid\n    const gridWithNeighbors = (grid) =>{\n        for(let i=0; i<rows; i++){\n            for(let j=0; j<cols; j++){\n                grid[i][j].addNeighbors(grid);\n            }\n        }\n    }\n\n    // JSX chunk: populate the grid with Node component\n    const gridWithNode = (\n        <div>\n            {\n            Grid.map( (row, rowIdx) => {\n                return(\n                    <div key={rowIdx} className='row-wrapper'>\n                        {row.map((cell, colIdx)=>{\n                            const { isStart, isEnd, isWall } = cell;\n                            return <Node \n                                    key={colIdx} \n                                    isStart={isStart} \n                                    isEnd={isEnd}\n                                    isWall={isWall}\n                                    row={rowIdx}\n                                    col={colIdx}\n                                />\n                        })}\n                    </div>\n                )\n            })}\n        </div>\n    );\n\n    const visualizeFinalPath = (nodesInPath) =>{\n        for(let i=0; i< nodesInPath.length; i++){\n            const node = nodesInPath[i];\n            if(!node.isStart && !node.isEnd){\n                const nodeElm = document.getElementById(`node-${node.x}-${node.y}`);\n                nodeElm.classList.add(\"shortest-path\");\n            }   \n        }\n    }\n    const visualize = ()=>{\n        console.log(\"Visualizing\");\n        for(let i=0; i<=visited.length; i++){\n            // If reaching the last one in visited records\n            if(i === visited.length){\n                setTimeout(()=>visualizeFinalPath(Path), 10*i+100);\n            }else{ // visualize the footprint\n                setTimeout( ()=>{\n                    const node = visited[i];\n                    if(!node.isStart && !node.isEnd){\n                        const nodeElm = document.getElementById(`node-${node.x}-${node.y}`);\n                        nodeElm.classList.add(\"visited\");\n                    }\n                }, 10*i);     \n            }\n        }\n    }\n    // const cleanUp = ()=>{ //??Figure out how to\n    //     setReset(true);\n    //     setGrid([]);\n    //     setPath([]);\n    //     setVisited([]);\n    //     initGrid();\n    //     setReset(false);\n    // }\n\n    const reloadPage = () =>{\n        window.location.reload();\n    }\n\n    return(\n        <div className='big-container'>\n            <h1 style={{color:'thistle'}}>Path Finder with A*</h1>\n            <div className=\"button-wrapper\">\n                <button onClick={visualize}>Visualize</button>\n                <button onClick={reloadPage}>Reset</button>\n            </div> \n            {gridWithNode}\n        </div>\n    ); \n}\n\nexport default PathFind;","import './App.css';\nimport PathFind from './components/PathFind';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFind />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}